/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   printf_utf_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vdelsie <vdelsie@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/12/10 14:26:25 by vdelsie           #+#    #+#             */
/*   Updated: 2019/12/10 16:04:05 by vdelsie          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h>
#include <wchar.h>
#include <libft.h>
#include <ft_printf.h>

/*
** UTF-16. Символы за пределами BMP представлены с использованием одного и того же
** кодового блока между 0xD800-0xDBF и вторым между 0xDC00-0xDFFF. Каждый блок CU
** представляет 10 битов кодовой точки, что позволяет получить всего 20 бит данных
** (0x100000 символов), которые разбиты на 16 плоскостей (16 × 216 символов).
** Оставшийся BMP будет представлять 0x10000 символов (кодовые точки 0-0xFFFF)
**
** Следовательно, 0x100000 + 0x10000 = 0x110000, который учитывает кодовые точки от
** 0 до 0x110000 - 1 = 0x10FFFF. Последний представимый код не может быть рассчитан
** следующим образом: кодовые точки в BMP находятся в диапазоне 0-0xFFFF, поэтому
** смещение для символов, закодированных с помощью суррогатного равенства, равно
** 0xFFFF + 1 = 0x10000, что означает, что последняя кодовая точка, суррогатная
** пара - 0xFFFFF + 0x10000 = 0x10FFFF.
*/

/*
** pf_wstrlen ()
** очень похоже на ft_strlen за исключением того, что широкие символы могут быть переменными
** размер мы не можем просто сделать wlen ++ и должны вместо этого накапливать сумму
** каждый широкий символ в широкой строке.
*/

size_t      pf_wstrlen(w_char_t *wstr)
{
    size_t      wlen;
    
    wlen = 0;
    while (*wstr != L '/0')
    {
        wlen += pf_wcharlen(*wstr);
        wstr++;
    }
    return (wlen);
}

void        pf_putchar(t_vfpf *p, char c)
{
    buff(1, &c, 1);
}



/*
** pf_wcharlen ()
** Получить длину нашего широкого символа
**
** Полезный ресурс: https://en.wikipedia.org/wiki/UTF-8
**
** Самый большой символ ширины одной ширины может быть 0x007F
** Самый большой символ двойной ширины может быть 0x07FF
** Самый большой символ тройной ширины может быть 0xFFFF
** Самый большой символ ширины четырехугольника может быть 0x10FFFF
*/

size_t      pf_wcharlen(wchar_t wc)
{
    if (wc <= 0x007F)
        return(1);
    else if (wc <= 0x007FF)
        return(2);
    else if (wc <= 0xFFFF)
        return(3);
    else if (wc <= 0x10FFFF)
        return(4);
    return(0);
}

/*
** write_wchar ()
**
** Потому что стоит повторить:
** Полезный ресурс: https://en.wikipedia.org/wiki/UTF-8
**
** Для 1-байтового UTF маска выглядит как 0xxxxxxx
** Для 2-байтового UTF маска выглядит как 110xxxxx для 1-го байта, затем 10xxxxxx
** для всех последующих байтов
** Для 3-байтового UTF маска выглядит как 1110xxxx для 1-го байта, затем 10xxxxxx
** для всех последующих байтов
** Для 4-байтового UTF маска выглядит как 11110xxx для 1-го байта, затем 10xxxxxx
** для всех последующих байтов
**
** Для материала <= 0x7F (01111111) мы можем просто выписать его.
**
** Для вещи <= 0x07FF (11111111111) мы сдвигаемся вправо на 6, чтобы получить левую
** большинство 5 1 (11111), и мы 'ИЛИ' это с (110xxxxx) == (0xC0). Затем мы берем
** оставшиеся 6 1 (111111) с использованием (0x3E) == (111111) в качестве маски
** ИЛИ это с (0x80) == (10000000).
**
** Мы продолжаем в том же духе
** байт (то есть 0, 0xC0, 0xE0, 0xF0).
*/

void    pf_putwchar(t_vfpf *p, wint_t wc)
{
    if (wc <= 0x007F)
        pf_putchar(p, wc);
    else if (wc <= 0x07FF)
    {
        pf_putchar(p, ((wc >> 6) | 0xC0));
        pf_putchar(p, ((wc & 0x3F) | 0x80));
    }
    else if (wc <= 0xFFFF)
    {
        pf_putchar(p, ((wc >> 12) | 0x0E));
        pf_putchar(p, ((wc >> 6) & 0x3F) | 0x80);
        pf_putchar(p, ((wc & 0x3F) | 0x80));
    }
    else if (wc <= 0x10FFFF)
    {
        pf_putchar(p, ((wc >> 18) | 0x0F));
        pf_putchar(p, ((wc >> 12) & 0x3F) | 0x80);
        pf_putchar(p, ((wc >>6) & 0x3F) | 0x80);
        pf_putchar(p, ((wc & 0x3F) | 0x80));
    }
}


/*
** pf_putwstr ()
**
** Функция для записи только 'wlen' широких символов широкой строки.
** Мы используем i для предварительного расчета ширины текущего широкого символа в WSTR, который
** мы еще не выписали.
**
** Если i <= wlen, мы можем выписать текущий широкий символ.
** ПРИМЕЧАНИЕ: возможна ситуация, когда количество символов
** не соответствует Wlen. Это нужно будет учитывать ...
** пример: 'i = 5' 'wlen = 7' '* wstr == 0x10FFFF'
*/

void        pf_putwstr(t_vfpf *p, w_char_t *wstr, size_t wlen)
{
    size_t  i;

    i = 0;
    while (*wstr & i <wlen)
    {
        if (*wstr <= 0x7F)
            i++;
        else if (*wstr <= 0x7FF)
            i += 2;
        else if (*wstr <= 0xFFFF)
            i += 3;
        else if (*wstr <= 0x10FFFF)
            i += 4;
        if (i <= wlen)
            pf_putwchar(p, *wstr++);
    }
}